/**
 * @file kalman.c
 * @author Javier Monz√≥n (mon20054@uvg.edu.gt
 * @brief Kalman Filter implementation for estimating the pose of a Pololu 3Pi+ 
 * using odometry from encoders as the prediction variables and an OptiTrack based 
 * MOCAP as the correction variables. 
 * @version 0.1
 * @date 2024
 * 
 * @copyright Copyright (c) 2024
 * 
 */

// ================================================================================
// Dependencies
// ================================================================================
#include <math.h>

// ================================================================================
// Public function definitions
// ================================================================================
void 
state_prediction(double drho, double dtheta, double theta_post,
                      double x_post, double y_post, volatile double * prediction)
{
  /* STATE_PREDICTION */
  /*     PREDICTION = STATE_PREDICTION(DRHO,DTHETA,THETA_POST,X_POST,Y_POST) */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     10-Aug-2024 11:42:24 */
  prediction[0] = x_post + drho * cos(theta_post);
  prediction[1] = y_post + drho * sin(theta_post);
  prediction[2] = dtheta + theta_post;
}

void 
var_prediction(double drho, double p11_post, double p12_post,
                    double p13_post, double p22_post, double p23_post,
                    double p33_post, double sigma_drho, double sigma_dtheta,
                    double theta_post, volatile double * P_prediction)
{
  double P_prediction_tmp;
  double b_P_prediction_tmp;
  double c_P_prediction_tmp;
  double t10;
  double t2;
  double t3;
  double t4;
  double t8;
  /* VAR_PREDICTION */
  /*     P_prediction =
   * VAR_PREDICTION(DRHO,P11_POST,P12_POST,P13_POST,P22_POST,P23_POST,P33_POST,SIGMA_DRHO,SIGMA_DTHETA,THETA_POST)
   */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     10-Aug-2024 11:42:24 */
  t2 = cos(theta_post);
  t3 = sin(theta_post);
  t4 = sigma_drho * sigma_drho;
  t10 = drho * p33_post;
  t8 = p23_post + t10 * t2;
  t10 = p13_post - t10 * t3;
  P_prediction_tmp = drho * p13_post;
  b_P_prediction_tmp = drho * t3;
  P_prediction[0] = ((p11_post + t2 * t2 * t4) - P_prediction_tmp * t3) -
                    b_P_prediction_tmp * t10;
  c_P_prediction_tmp = p12_post + t2 * t3 * t4;
  P_prediction[1] =
      (c_P_prediction_tmp + P_prediction_tmp * t2) - b_P_prediction_tmp * t8;
  P_prediction[2] = t10;
  P_prediction_tmp = drho * p23_post;
  b_P_prediction_tmp = drho * t2;
  P_prediction[3] =
      (c_P_prediction_tmp - P_prediction_tmp * t3) + b_P_prediction_tmp * t10;
  P_prediction[4] = ((p22_post + t3 * t3 * t4) + P_prediction_tmp * t2) +
                    b_P_prediction_tmp * t8;
  P_prediction[5] = t8;
  P_prediction[6] = t10;
  P_prediction[7] = t8;
  P_prediction[8] = p33_post + sigma_dtheta * sigma_dtheta;
}

void 
state_correction(double p11_prior, double p12_prior, double p13_prior,
                      double p22_prior, double p23_prior, double p33_prior,
                      double sigma_theta, double sigma_x, double sigma_y,
                      double thetaOT, double theta_prior, double xOT,
                      double x_prior, double yOT, double y_prior,
                      volatile double * correction)
{
  double b_correction_tmp;
  double c_correction_tmp;
  double correction_tmp;
  double d_correction_tmp;
  double e_correction_tmp;
  double f_correction_tmp;
  double g_correction_tmp;
  double h_correction_tmp;
  double dif_ang;
  double ang_correction;
  double t12_tmp;
  double t13_tmp;
  double t14_tmp;
  double t15_tmp;
  double t16;
  double t17;
  double t18;
  double t19;
  double t2;
  double t20;
  double t25;
  double t27_tmp;
  double t28_tmp;
  double t3;
  double t35;
  double t4;
  double t40;
  double t5;
  double t6;
  double t7;
  double t7_tmp;
  /* STATE_CORRECTION */
  /*     CORRECTION =
   * STATE_CORRECTION(P11_PRIOR,P12_PRIOR,P13_PRIOR,P22_PRIOR,P23_PRIOR,P33_PRIOR,SIGMA_THETA,SIGMA_X,SIGMA_Y,thetaOT,THETA_PRIOR,xOT,X_PRIOR,yOT,Y_PRIOR)
   */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     10-Aug-2024 11:42:24 */
  t2 = p12_prior * p12_prior;
  t3 = p13_prior * p13_prior;
  t4 = p23_prior * p23_prior;
  t5 = sigma_x * sigma_x;
  t6 = sigma_y * sigma_y;
  t7_tmp = p11_prior * p22_prior;
  t7 = t7_tmp * p33_prior;
  t16 = p12_prior * p13_prior * p23_prior * 2.0;
  t12_tmp = p11_prior * t4;
  t13_tmp = p22_prior * t3;
  t14_tmp = p33_prior * t2;
  t15_tmp = sigma_theta * t2;
  t17 = p11_prior * p33_prior * t6;
  t18 = p22_prior * p33_prior * t5;
  t19 = p11_prior * sigma_theta * t6;
  t20 = p22_prior * sigma_theta * t5;
  t25 = -y_prior + yOT;
  t27_tmp = t3 * t6;
  t28_tmp = t4 * t5;
  t35 = p33_prior * t5 * t6;
  t7_tmp = (t7 + t7_tmp * sigma_theta) + t16;
  t2 = t7_tmp + t17;
  t40 = 1.0 /
        (((((((((((t2 + t18) + t19) + t20) - t12_tmp) - t13_tmp) - t14_tmp) -
             t15_tmp) +
            t35) +
           sigma_theta * t5 * t6) -
          t27_tmp) -
         t28_tmp);
  correction_tmp = t25 * t40;
  b_correction_tmp = (-x_prior + xOT) * t40;
  c_correction_tmp = -p13_prior * p23_prior;
  d_correction_tmp = p12_prior * p33_prior;
  e_correction_tmp = p12_prior * sigma_theta;
  dif_ang = (-theta_prior + thetaOT);
  ang_correction = atan2(sin(dif_ang),cos(dif_ang));
  f_correction_tmp = ang_correction * t40;
  g_correction_tmp = -p12_prior * p23_prior;
  h_correction_tmp = p13_prior * p22_prior;
  correction[0] =
      ((x_prior +
        b_correction_tmp *
            ((((((t2 + t19) - t12_tmp) - t13_tmp) - t14_tmp) - t15_tmp) -
             t27_tmp)) +
       correction_tmp * ((c_correction_tmp * t5 + d_correction_tmp * t5) +
                         e_correction_tmp * t5)) +
      f_correction_tmp * ((g_correction_tmp * t5 + h_correction_tmp * t5) +
                          p13_prior * t5 * t6);
  t3 = -p12_prior * p13_prior;
  t4 = p11_prior * p23_prior;
  t2 = p23_prior * t5;
  correction[1] =
      ((y_prior +
        correction_tmp *
            (((((((t7_tmp + t18) + t20) - t12_tmp) - t13_tmp) - t14_tmp) -
              t15_tmp) -
             t28_tmp)) +
       b_correction_tmp * ((c_correction_tmp * t6 + d_correction_tmp * t6) +
                           e_correction_tmp * t6)) +
      f_correction_tmp * ((t3 * t6 + t4 * t6) + t2 * t6);
  correction[2] =
      ((theta_prior +
        f_correction_tmp *
            (((((((((t7 + t16) + t17) + t18) - t12_tmp) - t13_tmp) - t14_tmp) +
               t35) -
              t27_tmp) -
             t28_tmp)) +
       b_correction_tmp *
           ((g_correction_tmp * sigma_theta + h_correction_tmp * sigma_theta) +
            p13_prior * sigma_theta * t6)) +
      sigma_theta * t25 * t40 * ((t3 + t4) + t2);

      correction[2] = thetaOT;

      correction[2] = atan2(sin(correction[2]),cos(correction[2]));
}

void 
var_correction(double p11_prior, double p12_prior, double p13_prior,
                    double p22_prior, double p23_prior, double p33_prior,
                    double sigma_theta, double sigma_x, double sigma_y,
                    volatile double * P_correction)
{
  double t14_tmp;
  double t15_tmp;
  double t16_tmp;
  double t17;
  double t18_tmp;
  double t19;
  double t2;
  double t26;
  double t29;
  double t3;
  double t30;
  double t34;
  double t34_tmp;
  double t39_tmp;
  double t4;
  double t40_tmp;
  double t5;
  double t55;
  double t60;
  double t61;
  double t62;
  double t63;
  double t63_tmp;
  double t64;
  double t65;
  double t7;
  double t70;
  double t8;
  double t9;
  /* VAR_CORRECTION */
  /*     P_correction =
   * VAR_CORRECTION(P11_PRIOR,P12_PRIOR,P13_PRIOR,P22_PRIOR,P23_PRIOR,P33_PRIOR,SIGMA_THETA,SIGMA_X,SIGMA_Y)
   */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     10-Aug-2024 11:42:24 */
  t2 = p12_prior * p13_prior;
  t3 = p11_prior * p23_prior;
  t4 = p12_prior * p12_prior;
  t5 = p13_prior * p13_prior;
  t7 = sigma_x * sigma_x;
  t8 = sigma_y * sigma_y;
  t70 = p11_prior * p22_prior;
  t9 = t70 * p33_prior;
  t14_tmp = p23_prior * t3;
  t15_tmp = p22_prior * t5;
  t16_tmp = p33_prior * t4;
  t17 = p23_prior * t7;
  t18_tmp = sigma_theta * t4;
  t19 = p23_prior * t2 * 2.0;
  t26 = p11_prior * p33_prior * t8;
  t29 = p22_prior * p33_prior * t7;
  t30 = p11_prior * sigma_theta * t8;
  t34_tmp = p22_prior * sigma_theta;
  t34 = t34_tmp * t7;
  t39_tmp = t5 * t8;
  t40_tmp = p23_prior * p23_prior * t7;
  t55 = p33_prior * t7 * t8;
  t60 = (t3 - t2) + t17;
  t5 = p13_prior * p22_prior;
  t61 = (t5 * sigma_theta + p13_prior * sigma_theta * t8) -
        p12_prior * p23_prior * sigma_theta;
  t4 = p12_prior * p33_prior;
  t63_tmp = p12_prior * sigma_theta;
  t63 = (t4 * t8 + t63_tmp * t8) - p13_prior * p23_prior * t8;
  t65 = (t3 * t8 + t8 * -t2) + t8 * t17;
  t62 = (t4 * t7 + t63_tmp * t7) - p13_prior * t17;
  t64 = (t5 * t7 - p12_prior * t17) + p13_prior * t7 * t8;
  t5 = (t9 + t70 * sigma_theta) + t19;
  t4 = t5 + t26;
  t70 = 1.0 /
        (((((((((((t4 + t29) + t30) + t34) - t14_tmp) - t15_tmp) - t16_tmp) -
             t18_tmp) +
            t55) +
           sigma_theta * t7 * t8) -
          t39_tmp) -
         t40_tmp);
  t3 = (((((t4 + t30) - t14_tmp) - t15_tmp) - t16_tmp) - t18_tmp) - t39_tmp;
  P_correction[0] =
      ((p11_prior - p11_prior * t70 * t3) - p12_prior * t62 * t70) -
      p13_prior * t64 * t70;
  t17 = p12_prior * t70;
  t2 = ((((((t5 + t29) + t34) - t14_tmp) - t15_tmp) - t16_tmp) - t18_tmp) -
       t40_tmp;
  P_correction[1] =
      ((p12_prior - t17 * t2) - p11_prior * t63 * t70) - p13_prior * t65 * t70;
  t4 = ((((((((t9 + t19) + t26) + t29) - t14_tmp) - t15_tmp) - t16_tmp) + t55) -
        t39_tmp) -
       t40_tmp;
  t5 = p13_prior * t70;
  P_correction[2] =
      ((p13_prior - t5 * t4) - p11_prior * t61 * t70) - t63_tmp * t60 * t70;
  P_correction[3] =
      ((p12_prior - t17 * t3) - p22_prior * t62 * t70) - p23_prior * t64 * t70;
  P_correction[4] =
      ((p22_prior - p22_prior * t70 * t2) - p12_prior * t63 * t70) -
      p23_prior * t65 * t70;
  t17 = p23_prior * t70;
  P_correction[5] =
      ((p23_prior - t17 * t4) - p12_prior * t61 * t70) - t34_tmp * t60 * t70;
  P_correction[6] =
      ((p13_prior - t5 * t3) - p23_prior * t62 * t70) - p33_prior * t64 * t70;
  P_correction[7] =
      ((p23_prior - t17 * t2) - p13_prior * t63 * t70) - p33_prior * t65 * t70;
  P_correction[8] =
      ((p33_prior - p33_prior * t70 * t4) - p13_prior * t61 * t70) -
      p23_prior * sigma_theta * t60 * t70;
}
